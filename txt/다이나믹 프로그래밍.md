# 다이나믹 프로그래밍

------

큰 문제를 작은 문제로 나눠서 푸는 알고리즘

1. 겹치는 부분문제
2. 문제의 정답을 작은 문제의 정답으로 구할 수 있을 때

다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.

정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.

배열에 저장하는 것으로 할 수 있다.

메모를 한다고 해서 영어로 Memoization이라고 한다.

### Overlapping Subproblem

피보나치 수

* 문제: N번째 피보나치 수를 구하는 문제
* 작은 문제: N-1번째 피보나치 수, N-2번째 피보나치 수



### Optimal Substructure

문제의 정답을 작은 문제의 정답에서 구할 수 있다.





### 다이나믹을 푸는 두 가지 방법

1.Top-down

* 문제를 작은 문제로 나눈다.
* 작은 문제를 푼다.
* 작은 문제를 풀었으니, 이제 문제를 푼다.
* 재귀 호출을 이용해서 푼다.
* 시간복잡도 계산하는 방법 : 채워야하는 칸의 수(배열에 총 몇개의 개수가 채워질거냐) * 1칸을 채우는 수

2.Botton-up

* 문제를 크기가 작은 문제부터 차례대로 푼다.
* 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
* 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다
* for문 이용해서 푼다.





### 다이나믹 문제 풀이 전략

* 문제에서 구하려고 하는 답을 문장으로 나타낸다.
* 예: 피보나치 수를 구하는 문제
* N번째 피보나치 수
* 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다.
* Top-down인 경우에는 재귀 호출의 인자의 개수
* 문제를 작은 문제로 나누고, 수식을 이용해서 문제를 표현해야 한다.





## 1로 만들기

D[N] = N을 1로 만드는데 필요한 연산 수의 최소값

